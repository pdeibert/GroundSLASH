# Generated from SLASH.g4 by ANTLR 4.11.1
# encoding: utf-8
import sys
from io import StringIO

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    return [
        4,
        1,
        38,
        262,
        2,
        0,
        7,
        0,
        2,
        1,
        7,
        1,
        2,
        2,
        7,
        2,
        2,
        3,
        7,
        3,
        2,
        4,
        7,
        4,
        2,
        5,
        7,
        5,
        2,
        6,
        7,
        6,
        2,
        7,
        7,
        7,
        2,
        8,
        7,
        8,
        2,
        9,
        7,
        9,
        2,
        10,
        7,
        10,
        2,
        11,
        7,
        11,
        2,
        12,
        7,
        12,
        2,
        13,
        7,
        13,
        2,
        14,
        7,
        14,
        2,
        15,
        7,
        15,
        2,
        16,
        7,
        16,
        2,
        17,
        7,
        17,
        2,
        18,
        7,
        18,
        2,
        19,
        7,
        19,
        2,
        20,
        7,
        20,
        2,
        21,
        7,
        21,
        2,
        22,
        7,
        22,
        2,
        23,
        7,
        23,
        2,
        24,
        7,
        24,
        2,
        25,
        7,
        25,
        1,
        0,
        3,
        0,
        54,
        8,
        0,
        1,
        0,
        3,
        0,
        57,
        8,
        0,
        1,
        0,
        1,
        0,
        1,
        1,
        4,
        1,
        62,
        8,
        1,
        11,
        1,
        12,
        1,
        63,
        1,
        2,
        1,
        2,
        1,
        2,
        1,
        3,
        1,
        3,
        3,
        3,
        71,
        8,
        3,
        1,
        3,
        1,
        3,
        1,
        3,
        1,
        3,
        3,
        3,
        77,
        8,
        3,
        3,
        3,
        79,
        8,
        3,
        1,
        3,
        1,
        3,
        3,
        3,
        83,
        8,
        3,
        1,
        4,
        1,
        4,
        3,
        4,
        87,
        8,
        4,
        1,
        5,
        1,
        5,
        3,
        5,
        91,
        8,
        5,
        1,
        5,
        3,
        5,
        94,
        8,
        5,
        1,
        5,
        1,
        5,
        3,
        5,
        98,
        8,
        5,
        1,
        6,
        1,
        6,
        1,
        6,
        3,
        6,
        103,
        8,
        6,
        1,
        7,
        1,
        7,
        1,
        7,
        3,
        7,
        108,
        8,
        7,
        1,
        7,
        1,
        7,
        3,
        7,
        112,
        8,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        1,
        7,
        3,
        7,
        118,
        8,
        7,
        1,
        8,
        1,
        8,
        1,
        8,
        3,
        8,
        123,
        8,
        8,
        1,
        9,
        1,
        9,
        1,
        9,
        3,
        9,
        128,
        8,
        9,
        3,
        9,
        130,
        8,
        9,
        1,
        10,
        1,
        10,
        1,
        10,
        3,
        10,
        135,
        8,
        10,
        1,
        10,
        1,
        10,
        1,
        10,
        3,
        10,
        140,
        8,
        10,
        1,
        10,
        1,
        10,
        1,
        10,
        1,
        10,
        3,
        10,
        146,
        8,
        10,
        1,
        11,
        1,
        11,
        1,
        11,
        3,
        11,
        151,
        8,
        11,
        1,
        12,
        1,
        12,
        3,
        12,
        155,
        8,
        12,
        1,
        12,
        1,
        12,
        3,
        12,
        159,
        8,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        3,
        12,
        165,
        8,
        12,
        1,
        13,
        1,
        13,
        1,
        14,
        1,
        14,
        1,
        14,
        3,
        14,
        172,
        8,
        14,
        1,
        15,
        3,
        15,
        175,
        8,
        15,
        1,
        15,
        1,
        15,
        3,
        15,
        179,
        8,
        15,
        1,
        16,
        3,
        16,
        182,
        8,
        16,
        1,
        16,
        1,
        16,
        1,
        16,
        3,
        16,
        187,
        8,
        16,
        1,
        16,
        3,
        16,
        190,
        8,
        16,
        1,
        17,
        1,
        17,
        1,
        17,
        1,
        17,
        1,
        18,
        1,
        18,
        1,
        19,
        1,
        19,
        1,
        19,
        3,
        19,
        201,
        8,
        19,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        3,
        20,
        213,
        8,
        20,
        1,
        21,
        1,
        21,
        1,
        21,
        3,
        21,
        218,
        8,
        21,
        1,
        21,
        1,
        21,
        1,
        22,
        1,
        22,
        1,
        23,
        1,
        23,
        1,
        23,
        1,
        23,
        1,
        23,
        1,
        23,
        1,
        23,
        1,
        23,
        1,
        23,
        5,
        23,
        233,
        8,
        23,
        10,
        23,
        12,
        23,
        236,
        9,
        23,
        1,
        24,
        1,
        24,
        1,
        24,
        1,
        24,
        1,
        24,
        1,
        24,
        1,
        24,
        1,
        24,
        1,
        24,
        5,
        24,
        247,
        8,
        24,
        10,
        24,
        12,
        24,
        250,
        9,
        24,
        1,
        25,
        1,
        25,
        1,
        25,
        1,
        25,
        1,
        25,
        1,
        25,
        1,
        25,
        1,
        25,
        3,
        25,
        260,
        8,
        25,
        1,
        25,
        0,
        2,
        46,
        48,
        26,
        0,
        2,
        4,
        6,
        8,
        10,
        12,
        14,
        16,
        18,
        20,
        22,
        24,
        26,
        28,
        30,
        32,
        34,
        36,
        38,
        40,
        42,
        44,
        46,
        48,
        50,
        0,
        2,
        1,
        0,
        32,
        35,
        1,
        0,
        26,
        31,
        282,
        0,
        53,
        1,
        0,
        0,
        0,
        2,
        61,
        1,
        0,
        0,
        0,
        4,
        65,
        1,
        0,
        0,
        0,
        6,
        82,
        1,
        0,
        0,
        0,
        8,
        86,
        1,
        0,
        0,
        0,
        10,
        93,
        1,
        0,
        0,
        0,
        12,
        99,
        1,
        0,
        0,
        0,
        14,
        107,
        1,
        0,
        0,
        0,
        16,
        119,
        1,
        0,
        0,
        0,
        18,
        124,
        1,
        0,
        0,
        0,
        20,
        134,
        1,
        0,
        0,
        0,
        22,
        147,
        1,
        0,
        0,
        0,
        24,
        164,
        1,
        0,
        0,
        0,
        26,
        166,
        1,
        0,
        0,
        0,
        28,
        168,
        1,
        0,
        0,
        0,
        30,
        178,
        1,
        0,
        0,
        0,
        32,
        181,
        1,
        0,
        0,
        0,
        34,
        191,
        1,
        0,
        0,
        0,
        36,
        195,
        1,
        0,
        0,
        0,
        38,
        197,
        1,
        0,
        0,
        0,
        40,
        212,
        1,
        0,
        0,
        0,
        42,
        214,
        1,
        0,
        0,
        0,
        44,
        221,
        1,
        0,
        0,
        0,
        46,
        223,
        1,
        0,
        0,
        0,
        48,
        237,
        1,
        0,
        0,
        0,
        50,
        259,
        1,
        0,
        0,
        0,
        52,
        54,
        3,
        2,
        1,
        0,
        53,
        52,
        1,
        0,
        0,
        0,
        53,
        54,
        1,
        0,
        0,
        0,
        54,
        56,
        1,
        0,
        0,
        0,
        55,
        57,
        3,
        4,
        2,
        0,
        56,
        55,
        1,
        0,
        0,
        0,
        56,
        57,
        1,
        0,
        0,
        0,
        57,
        58,
        1,
        0,
        0,
        0,
        58,
        59,
        5,
        0,
        0,
        1,
        59,
        1,
        1,
        0,
        0,
        0,
        60,
        62,
        3,
        6,
        3,
        0,
        61,
        60,
        1,
        0,
        0,
        0,
        62,
        63,
        1,
        0,
        0,
        0,
        63,
        61,
        1,
        0,
        0,
        0,
        63,
        64,
        1,
        0,
        0,
        0,
        64,
        3,
        1,
        0,
        0,
        0,
        65,
        66,
        3,
        32,
        16,
        0,
        66,
        67,
        5,
        9,
        0,
        0,
        67,
        5,
        1,
        0,
        0,
        0,
        68,
        70,
        5,
        13,
        0,
        0,
        69,
        71,
        3,
        10,
        5,
        0,
        70,
        69,
        1,
        0,
        0,
        0,
        70,
        71,
        1,
        0,
        0,
        0,
        71,
        72,
        1,
        0,
        0,
        0,
        72,
        83,
        5,
        7,
        0,
        0,
        73,
        78,
        3,
        8,
        4,
        0,
        74,
        76,
        5,
        13,
        0,
        0,
        75,
        77,
        3,
        10,
        5,
        0,
        76,
        75,
        1,
        0,
        0,
        0,
        76,
        77,
        1,
        0,
        0,
        0,
        77,
        79,
        1,
        0,
        0,
        0,
        78,
        74,
        1,
        0,
        0,
        0,
        78,
        79,
        1,
        0,
        0,
        0,
        79,
        80,
        1,
        0,
        0,
        0,
        80,
        81,
        5,
        7,
        0,
        0,
        81,
        83,
        1,
        0,
        0,
        0,
        82,
        68,
        1,
        0,
        0,
        0,
        82,
        73,
        1,
        0,
        0,
        0,
        83,
        7,
        1,
        0,
        0,
        0,
        84,
        87,
        3,
        12,
        6,
        0,
        85,
        87,
        3,
        14,
        7,
        0,
        86,
        84,
        1,
        0,
        0,
        0,
        86,
        85,
        1,
        0,
        0,
        0,
        87,
        9,
        1,
        0,
        0,
        0,
        88,
        94,
        3,
        30,
        15,
        0,
        89,
        91,
        5,
        1,
        0,
        0,
        90,
        89,
        1,
        0,
        0,
        0,
        90,
        91,
        1,
        0,
        0,
        0,
        91,
        92,
        1,
        0,
        0,
        0,
        92,
        94,
        3,
        20,
        10,
        0,
        93,
        88,
        1,
        0,
        0,
        0,
        93,
        90,
        1,
        0,
        0,
        0,
        94,
        97,
        1,
        0,
        0,
        0,
        95,
        96,
        5,
        8,
        0,
        0,
        96,
        98,
        3,
        10,
        5,
        0,
        97,
        95,
        1,
        0,
        0,
        0,
        97,
        98,
        1,
        0,
        0,
        0,
        98,
        11,
        1,
        0,
        0,
        0,
        99,
        102,
        3,
        32,
        16,
        0,
        100,
        101,
        5,
        12,
        0,
        0,
        101,
        103,
        3,
        12,
        6,
        0,
        102,
        100,
        1,
        0,
        0,
        0,
        102,
        103,
        1,
        0,
        0,
        0,
        103,
        13,
        1,
        0,
        0,
        0,
        104,
        105,
        3,
        40,
        20,
        0,
        105,
        106,
        3,
        36,
        18,
        0,
        106,
        108,
        1,
        0,
        0,
        0,
        107,
        104,
        1,
        0,
        0,
        0,
        107,
        108,
        1,
        0,
        0,
        0,
        108,
        109,
        1,
        0,
        0,
        0,
        109,
        111,
        5,
        24,
        0,
        0,
        110,
        112,
        3,
        16,
        8,
        0,
        111,
        110,
        1,
        0,
        0,
        0,
        111,
        112,
        1,
        0,
        0,
        0,
        112,
        113,
        1,
        0,
        0,
        0,
        113,
        117,
        5,
        25,
        0,
        0,
        114,
        115,
        3,
        36,
        18,
        0,
        115,
        116,
        3,
        40,
        20,
        0,
        116,
        118,
        1,
        0,
        0,
        0,
        117,
        114,
        1,
        0,
        0,
        0,
        117,
        118,
        1,
        0,
        0,
        0,
        118,
        15,
        1,
        0,
        0,
        0,
        119,
        122,
        3,
        18,
        9,
        0,
        120,
        121,
        5,
        11,
        0,
        0,
        121,
        123,
        3,
        16,
        8,
        0,
        122,
        120,
        1,
        0,
        0,
        0,
        122,
        123,
        1,
        0,
        0,
        0,
        123,
        17,
        1,
        0,
        0,
        0,
        124,
        129,
        3,
        32,
        16,
        0,
        125,
        127,
        5,
        10,
        0,
        0,
        126,
        128,
        3,
        28,
        14,
        0,
        127,
        126,
        1,
        0,
        0,
        0,
        127,
        128,
        1,
        0,
        0,
        0,
        128,
        130,
        1,
        0,
        0,
        0,
        129,
        125,
        1,
        0,
        0,
        0,
        129,
        130,
        1,
        0,
        0,
        0,
        130,
        19,
        1,
        0,
        0,
        0,
        131,
        132,
        3,
        40,
        20,
        0,
        132,
        133,
        3,
        36,
        18,
        0,
        133,
        135,
        1,
        0,
        0,
        0,
        134,
        131,
        1,
        0,
        0,
        0,
        134,
        135,
        1,
        0,
        0,
        0,
        135,
        136,
        1,
        0,
        0,
        0,
        136,
        137,
        3,
        26,
        13,
        0,
        137,
        139,
        5,
        24,
        0,
        0,
        138,
        140,
        3,
        22,
        11,
        0,
        139,
        138,
        1,
        0,
        0,
        0,
        139,
        140,
        1,
        0,
        0,
        0,
        140,
        141,
        1,
        0,
        0,
        0,
        141,
        145,
        5,
        25,
        0,
        0,
        142,
        143,
        3,
        36,
        18,
        0,
        143,
        144,
        3,
        40,
        20,
        0,
        144,
        146,
        1,
        0,
        0,
        0,
        145,
        142,
        1,
        0,
        0,
        0,
        145,
        146,
        1,
        0,
        0,
        0,
        146,
        21,
        1,
        0,
        0,
        0,
        147,
        150,
        3,
        24,
        12,
        0,
        148,
        149,
        5,
        11,
        0,
        0,
        149,
        151,
        3,
        22,
        11,
        0,
        150,
        148,
        1,
        0,
        0,
        0,
        150,
        151,
        1,
        0,
        0,
        0,
        151,
        23,
        1,
        0,
        0,
        0,
        152,
        154,
        3,
        38,
        19,
        0,
        153,
        155,
        5,
        10,
        0,
        0,
        154,
        153,
        1,
        0,
        0,
        0,
        154,
        155,
        1,
        0,
        0,
        0,
        155,
        165,
        1,
        0,
        0,
        0,
        156,
        158,
        5,
        10,
        0,
        0,
        157,
        159,
        3,
        28,
        14,
        0,
        158,
        157,
        1,
        0,
        0,
        0,
        158,
        159,
        1,
        0,
        0,
        0,
        159,
        165,
        1,
        0,
        0,
        0,
        160,
        161,
        3,
        38,
        19,
        0,
        161,
        162,
        5,
        10,
        0,
        0,
        162,
        163,
        3,
        28,
        14,
        0,
        163,
        165,
        1,
        0,
        0,
        0,
        164,
        152,
        1,
        0,
        0,
        0,
        164,
        156,
        1,
        0,
        0,
        0,
        164,
        160,
        1,
        0,
        0,
        0,
        165,
        25,
        1,
        0,
        0,
        0,
        166,
        167,
        7,
        0,
        0,
        0,
        167,
        27,
        1,
        0,
        0,
        0,
        168,
        171,
        3,
        30,
        15,
        0,
        169,
        170,
        5,
        8,
        0,
        0,
        170,
        172,
        3,
        28,
        14,
        0,
        171,
        169,
        1,
        0,
        0,
        0,
        171,
        172,
        1,
        0,
        0,
        0,
        172,
        29,
        1,
        0,
        0,
        0,
        173,
        175,
        5,
        1,
        0,
        0,
        174,
        173,
        1,
        0,
        0,
        0,
        174,
        175,
        1,
        0,
        0,
        0,
        175,
        176,
        1,
        0,
        0,
        0,
        176,
        179,
        3,
        32,
        16,
        0,
        177,
        179,
        3,
        34,
        17,
        0,
        178,
        174,
        1,
        0,
        0,
        0,
        178,
        177,
        1,
        0,
        0,
        0,
        179,
        31,
        1,
        0,
        0,
        0,
        180,
        182,
        5,
        16,
        0,
        0,
        181,
        180,
        1,
        0,
        0,
        0,
        181,
        182,
        1,
        0,
        0,
        0,
        182,
        183,
        1,
        0,
        0,
        0,
        183,
        189,
        5,
        2,
        0,
        0,
        184,
        186,
        5,
        20,
        0,
        0,
        185,
        187,
        3,
        38,
        19,
        0,
        186,
        185,
        1,
        0,
        0,
        0,
        186,
        187,
        1,
        0,
        0,
        0,
        187,
        188,
        1,
        0,
        0,
        0,
        188,
        190,
        5,
        21,
        0,
        0,
        189,
        184,
        1,
        0,
        0,
        0,
        189,
        190,
        1,
        0,
        0,
        0,
        190,
        33,
        1,
        0,
        0,
        0,
        191,
        192,
        3,
        40,
        20,
        0,
        192,
        193,
        3,
        36,
        18,
        0,
        193,
        194,
        3,
        40,
        20,
        0,
        194,
        35,
        1,
        0,
        0,
        0,
        195,
        196,
        7,
        1,
        0,
        0,
        196,
        37,
        1,
        0,
        0,
        0,
        197,
        200,
        3,
        40,
        20,
        0,
        198,
        199,
        5,
        8,
        0,
        0,
        199,
        201,
        3,
        38,
        19,
        0,
        200,
        198,
        1,
        0,
        0,
        0,
        200,
        201,
        1,
        0,
        0,
        0,
        201,
        39,
        1,
        0,
        0,
        0,
        202,
        213,
        5,
        2,
        0,
        0,
        203,
        213,
        5,
        4,
        0,
        0,
        204,
        213,
        5,
        3,
        0,
        0,
        205,
        213,
        5,
        6,
        0,
        0,
        206,
        207,
        5,
        20,
        0,
        0,
        207,
        208,
        3,
        40,
        20,
        0,
        208,
        209,
        5,
        21,
        0,
        0,
        209,
        213,
        1,
        0,
        0,
        0,
        210,
        213,
        3,
        42,
        21,
        0,
        211,
        213,
        3,
        44,
        22,
        0,
        212,
        202,
        1,
        0,
        0,
        0,
        212,
        203,
        1,
        0,
        0,
        0,
        212,
        204,
        1,
        0,
        0,
        0,
        212,
        205,
        1,
        0,
        0,
        0,
        212,
        206,
        1,
        0,
        0,
        0,
        212,
        210,
        1,
        0,
        0,
        0,
        212,
        211,
        1,
        0,
        0,
        0,
        213,
        41,
        1,
        0,
        0,
        0,
        214,
        215,
        5,
        2,
        0,
        0,
        215,
        217,
        5,
        20,
        0,
        0,
        216,
        218,
        3,
        38,
        19,
        0,
        217,
        216,
        1,
        0,
        0,
        0,
        217,
        218,
        1,
        0,
        0,
        0,
        218,
        219,
        1,
        0,
        0,
        0,
        219,
        220,
        5,
        21,
        0,
        0,
        220,
        43,
        1,
        0,
        0,
        0,
        221,
        222,
        3,
        46,
        23,
        0,
        222,
        45,
        1,
        0,
        0,
        0,
        223,
        224,
        6,
        23,
        -1,
        0,
        224,
        225,
        3,
        48,
        24,
        0,
        225,
        234,
        1,
        0,
        0,
        0,
        226,
        227,
        10,
        2,
        0,
        0,
        227,
        228,
        5,
        15,
        0,
        0,
        228,
        233,
        3,
        48,
        24,
        0,
        229,
        230,
        10,
        1,
        0,
        0,
        230,
        231,
        5,
        16,
        0,
        0,
        231,
        233,
        3,
        48,
        24,
        0,
        232,
        226,
        1,
        0,
        0,
        0,
        232,
        229,
        1,
        0,
        0,
        0,
        233,
        236,
        1,
        0,
        0,
        0,
        234,
        232,
        1,
        0,
        0,
        0,
        234,
        235,
        1,
        0,
        0,
        0,
        235,
        47,
        1,
        0,
        0,
        0,
        236,
        234,
        1,
        0,
        0,
        0,
        237,
        238,
        6,
        24,
        -1,
        0,
        238,
        239,
        3,
        50,
        25,
        0,
        239,
        248,
        1,
        0,
        0,
        0,
        240,
        241,
        10,
        2,
        0,
        0,
        241,
        242,
        5,
        17,
        0,
        0,
        242,
        247,
        3,
        50,
        25,
        0,
        243,
        244,
        10,
        1,
        0,
        0,
        244,
        245,
        5,
        18,
        0,
        0,
        245,
        247,
        3,
        50,
        25,
        0,
        246,
        240,
        1,
        0,
        0,
        0,
        246,
        243,
        1,
        0,
        0,
        0,
        247,
        250,
        1,
        0,
        0,
        0,
        248,
        246,
        1,
        0,
        0,
        0,
        248,
        249,
        1,
        0,
        0,
        0,
        249,
        49,
        1,
        0,
        0,
        0,
        250,
        248,
        1,
        0,
        0,
        0,
        251,
        260,
        5,
        5,
        0,
        0,
        252,
        260,
        5,
        3,
        0,
        0,
        253,
        254,
        5,
        16,
        0,
        0,
        254,
        260,
        3,
        50,
        25,
        0,
        255,
        256,
        5,
        20,
        0,
        0,
        256,
        257,
        3,
        46,
        23,
        0,
        257,
        258,
        5,
        21,
        0,
        0,
        258,
        260,
        1,
        0,
        0,
        0,
        259,
        251,
        1,
        0,
        0,
        0,
        259,
        252,
        1,
        0,
        0,
        0,
        259,
        253,
        1,
        0,
        0,
        0,
        259,
        255,
        1,
        0,
        0,
        0,
        260,
        51,
        1,
        0,
        0,
        0,
        39,
        53,
        56,
        63,
        70,
        76,
        78,
        82,
        86,
        90,
        93,
        97,
        102,
        107,
        111,
        117,
        122,
        127,
        129,
        134,
        139,
        145,
        150,
        154,
        158,
        164,
        171,
        174,
        178,
        181,
        186,
        189,
        200,
        212,
        217,
        232,
        234,
        246,
        248,
        259,
    ]


class SLASHParser(Parser):

    grammarFileName = "SLASH.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "'not'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'_'",
        "'.'",
        "','",
        "'?'",
        "':'",
        "';'",
        "'|'",
        "':-'",
        "':~'",
        "'+'",
        "'-'",
        "'*'",
        "'/'",
        "'@'",
        "'('",
        "')'",
        "'['",
        "']'",
        "'{'",
        "'}'",
        "'='",
        "'!='",
        "'<'",
        "'>'",
        "'<='",
        "'>='",
        "'#count'",
        "'#max'",
        "'#min'",
        "'#sum'",
    ]

    symbolicNames = [
        "<INVALID>",
        "NAF",
        "ID",
        "VARIABLE",
        "STRING",
        "NUMBER",
        "ANONYMOUS_VARIABLE",
        "DOT",
        "COMMA",
        "QUERY_MARK",
        "COLON",
        "SEMICOLON",
        "OR",
        "CONS",
        "WCONS",
        "PLUS",
        "MINUS",
        "TIMES",
        "DIV",
        "AT",
        "PAREN_OPEN",
        "PAREN_CLOSE",
        "SQUARE_OPEN",
        "SQUARE_CLOSE",
        "CURLY_OPEN",
        "CURLY_CLOSE",
        "EQUAL",
        "UNEQUAL",
        "LESS",
        "GREATER",
        "LESS_OR_EQ",
        "GREATER_OR_EQ",
        "COUNT",
        "MAX",
        "MIN",
        "SUM",
        "COMMENT",
        "MULTI_LINE_COMMENT",
        "BLANK",
    ]

    RULE_program = 0
    RULE_statements = 1
    RULE_query = 2
    RULE_statement = 3
    RULE_head = 4
    RULE_body = 5
    RULE_disjunction = 6
    RULE_choice = 7
    RULE_choice_elements = 8
    RULE_choice_element = 9
    RULE_aggregate = 10
    RULE_aggregate_elements = 11
    RULE_aggregate_element = 12
    RULE_aggregate_function = 13
    RULE_naf_literals = 14
    RULE_naf_literal = 15
    RULE_classical_literal = 16
    RULE_builtin_atom = 17
    RULE_relop = 18
    RULE_terms = 19
    RULE_term = 20
    RULE_func_term = 21
    RULE_arith_term = 22
    RULE_arith_sum = 23
    RULE_arith_prod = 24
    RULE_arith_atom = 25

    ruleNames = [
        "program",
        "statements",
        "query",
        "statement",
        "head",
        "body",
        "disjunction",
        "choice",
        "choice_elements",
        "choice_element",
        "aggregate",
        "aggregate_elements",
        "aggregate_element",
        "aggregate_function",
        "naf_literals",
        "naf_literal",
        "classical_literal",
        "builtin_atom",
        "relop",
        "terms",
        "term",
        "func_term",
        "arith_term",
        "arith_sum",
        "arith_prod",
        "arith_atom",
    ]

    EOF = Token.EOF
    NAF = 1
    ID = 2
    VARIABLE = 3
    STRING = 4
    NUMBER = 5
    ANONYMOUS_VARIABLE = 6
    DOT = 7
    COMMA = 8
    QUERY_MARK = 9
    COLON = 10
    SEMICOLON = 11
    OR = 12
    CONS = 13
    WCONS = 14
    PLUS = 15
    MINUS = 16
    TIMES = 17
    DIV = 18
    AT = 19
    PAREN_OPEN = 20
    PAREN_CLOSE = 21
    SQUARE_OPEN = 22
    SQUARE_CLOSE = 23
    CURLY_OPEN = 24
    CURLY_CLOSE = 25
    EQUAL = 26
    UNEQUAL = 27
    LESS = 28
    GREATER = 29
    LESS_OR_EQ = 30
    GREATER_OR_EQ = 31
    COUNT = 32
    MAX = 33
    MIN = 34
    SUM = 35
    COMMENT = 36
    MULTI_LINE_COMMENT = 37
    BLANK = 38

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(
            self, self.atn, self.decisionsToDFA, self.sharedContextCache
        )
        self._predicates = None

    class ProgramContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SLASHParser.EOF, 0)

        def statements(self):
            return self.getTypedRuleContext(SLASHParser.StatementsContext, 0)

        def query(self):
            return self.getTypedRuleContext(SLASHParser.QueryContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_program

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProgram"):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)

    def program(self):

        localctx = SLASHParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 0, self._ctx)
            if la_ == 1:
                self.state = 52
                self.statements()

            self.state = 56
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 2 or _la == 16:
                self.state = 55
                self.query()

            self.state = 58
            self.match(SLASHParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SLASHParser.StatementContext)
            else:
                return self.getTypedRuleContext(SLASHParser.StatementContext, i)

        def getRuleIndex(self):
            return SLASHParser.RULE_statements

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatements"):
                return visitor.visitStatements(self)
            else:
                return visitor.visitChildren(self)

    def statements(self):

        localctx = SLASHParser.StatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 60
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 63
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 2, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QueryContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classical_literal(self):
            return self.getTypedRuleContext(SLASHParser.Classical_literalContext, 0)

        def QUERY_MARK(self):
            return self.getToken(SLASHParser.QUERY_MARK, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_query

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery"):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)

    def query(self):

        localctx = SLASHParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self.classical_literal()
            self.state = 66
            self.match(SLASHParser.QUERY_MARK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONS(self):
            return self.getToken(SLASHParser.CONS, 0)

        def DOT(self):
            return self.getToken(SLASHParser.DOT, 0)

        def body(self):
            return self.getTypedRuleContext(SLASHParser.BodyContext, 0)

        def head(self):
            return self.getTypedRuleContext(SLASHParser.HeadContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_statement

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)

    def statement(self):

        localctx = SLASHParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statement)
        self._la = 0  # Token type
        try:
            self.state = 82
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.match(SLASHParser.CONS)
                self.state = 70
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3F) == 0 and ((1 << _la) & 64425623678) != 0:
                    self.state = 69
                    self.body()

                self.state = 72
                self.match(SLASHParser.DOT)
                pass
            elif token in [2, 3, 4, 5, 6, 16, 20, 24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 73
                self.head()
                self.state = 78
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 13:
                    self.state = 74
                    self.match(SLASHParser.CONS)
                    self.state = 76
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((_la) & ~0x3F) == 0 and ((1 << _la) & 64425623678) != 0:
                        self.state = 75
                        self.body()

                self.state = 80
                self.match(SLASHParser.DOT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HeadContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def disjunction(self):
            return self.getTypedRuleContext(SLASHParser.DisjunctionContext, 0)

        def choice(self):
            return self.getTypedRuleContext(SLASHParser.ChoiceContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_head

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitHead"):
                return visitor.visitHead(self)
            else:
                return visitor.visitChildren(self)

    def head(self):

        localctx = SLASHParser.HeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_head)
        try:
            self.state = 86
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 7, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 84
                self.disjunction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 85
                self.choice()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BodyContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naf_literal(self):
            return self.getTypedRuleContext(SLASHParser.Naf_literalContext, 0)

        def aggregate(self):
            return self.getTypedRuleContext(SLASHParser.AggregateContext, 0)

        def COMMA(self):
            return self.getToken(SLASHParser.COMMA, 0)

        def body(self):
            return self.getTypedRuleContext(SLASHParser.BodyContext, 0)

        def NAF(self):
            return self.getToken(SLASHParser.NAF, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_body

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBody"):
                return visitor.visitBody(self)
            else:
                return visitor.visitChildren(self)

    def body(self):

        localctx = SLASHParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_body)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 9, self._ctx)
            if la_ == 1:
                self.state = 88
                self.naf_literal()
                pass

            elif la_ == 2:
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 1:
                    self.state = 89
                    self.match(SLASHParser.NAF)

                self.state = 92
                self.aggregate()
                pass

            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 8:
                self.state = 95
                self.match(SLASHParser.COMMA)
                self.state = 96
                self.body()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DisjunctionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classical_literal(self):
            return self.getTypedRuleContext(SLASHParser.Classical_literalContext, 0)

        def OR(self):
            return self.getToken(SLASHParser.OR, 0)

        def disjunction(self):
            return self.getTypedRuleContext(SLASHParser.DisjunctionContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_disjunction

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDisjunction"):
                return visitor.visitDisjunction(self)
            else:
                return visitor.visitChildren(self)

    def disjunction(self):

        localctx = SLASHParser.DisjunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_disjunction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.classical_literal()
            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 12:
                self.state = 100
                self.match(SLASHParser.OR)
                self.state = 101
                self.disjunction()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ChoiceContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURLY_OPEN(self):
            return self.getToken(SLASHParser.CURLY_OPEN, 0)

        def CURLY_CLOSE(self):
            return self.getToken(SLASHParser.CURLY_CLOSE, 0)

        def term(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SLASHParser.TermContext)
            else:
                return self.getTypedRuleContext(SLASHParser.TermContext, i)

        def relop(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SLASHParser.RelopContext)
            else:
                return self.getTypedRuleContext(SLASHParser.RelopContext, i)

        def choice_elements(self):
            return self.getTypedRuleContext(SLASHParser.Choice_elementsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_choice

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitChoice"):
                return visitor.visitChoice(self)
            else:
                return visitor.visitChildren(self)

    def choice(self):

        localctx = SLASHParser.ChoiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_choice)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1114236) != 0:
                self.state = 104
                self.term()
                self.state = 105
                self.relop()

            self.state = 109
            self.match(SLASHParser.CURLY_OPEN)
            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 2 or _la == 16:
                self.state = 110
                self.choice_elements()

            self.state = 113
            self.match(SLASHParser.CURLY_CLOSE)
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 4227858432) != 0:
                self.state = 114
                self.relop()
                self.state = 115
                self.term()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Choice_elementsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def choice_element(self):
            return self.getTypedRuleContext(SLASHParser.Choice_elementContext, 0)

        def SEMICOLON(self):
            return self.getToken(SLASHParser.SEMICOLON, 0)

        def choice_elements(self):
            return self.getTypedRuleContext(SLASHParser.Choice_elementsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_choice_elements

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitChoice_elements"):
                return visitor.visitChoice_elements(self)
            else:
                return visitor.visitChildren(self)

    def choice_elements(self):

        localctx = SLASHParser.Choice_elementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_choice_elements)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.choice_element()
            self.state = 122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 11:
                self.state = 120
                self.match(SLASHParser.SEMICOLON)
                self.state = 121
                self.choice_elements()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Choice_elementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classical_literal(self):
            return self.getTypedRuleContext(SLASHParser.Classical_literalContext, 0)

        def COLON(self):
            return self.getToken(SLASHParser.COLON, 0)

        def naf_literals(self):
            return self.getTypedRuleContext(SLASHParser.Naf_literalsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_choice_element

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitChoice_element"):
                return visitor.visitChoice_element(self)
            else:
                return visitor.visitChildren(self)

    def choice_element(self):

        localctx = SLASHParser.Choice_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_choice_element)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            self.classical_literal()
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 10:
                self.state = 125
                self.match(SLASHParser.COLON)
                self.state = 127
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1114238) != 0:
                    self.state = 126
                    self.naf_literals()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggregateContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregate_function(self):
            return self.getTypedRuleContext(SLASHParser.Aggregate_functionContext, 0)

        def CURLY_OPEN(self):
            return self.getToken(SLASHParser.CURLY_OPEN, 0)

        def CURLY_CLOSE(self):
            return self.getToken(SLASHParser.CURLY_CLOSE, 0)

        def term(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SLASHParser.TermContext)
            else:
                return self.getTypedRuleContext(SLASHParser.TermContext, i)

        def relop(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SLASHParser.RelopContext)
            else:
                return self.getTypedRuleContext(SLASHParser.RelopContext, i)

        def aggregate_elements(self):
            return self.getTypedRuleContext(SLASHParser.Aggregate_elementsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_aggregate

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAggregate"):
                return visitor.visitAggregate(self)
            else:
                return visitor.visitChildren(self)

    def aggregate(self):

        localctx = SLASHParser.AggregateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_aggregate)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1114236) != 0:
                self.state = 131
                self.term()
                self.state = 132
                self.relop()

            self.state = 136
            self.aggregate_function()
            self.state = 137
            self.match(SLASHParser.CURLY_OPEN)
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1115260) != 0:
                self.state = 138
                self.aggregate_elements()

            self.state = 141
            self.match(SLASHParser.CURLY_CLOSE)
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 4227858432) != 0:
                self.state = 142
                self.relop()
                self.state = 143
                self.term()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Aggregate_elementsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregate_element(self):
            return self.getTypedRuleContext(SLASHParser.Aggregate_elementContext, 0)

        def SEMICOLON(self):
            return self.getToken(SLASHParser.SEMICOLON, 0)

        def aggregate_elements(self):
            return self.getTypedRuleContext(SLASHParser.Aggregate_elementsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_aggregate_elements

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAggregate_elements"):
                return visitor.visitAggregate_elements(self)
            else:
                return visitor.visitChildren(self)

    def aggregate_elements(self):

        localctx = SLASHParser.Aggregate_elementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_aggregate_elements)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            self.aggregate_element()
            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 11:
                self.state = 148
                self.match(SLASHParser.SEMICOLON)
                self.state = 149
                self.aggregate_elements()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Aggregate_elementContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def terms(self):
            return self.getTypedRuleContext(SLASHParser.TermsContext, 0)

        def COLON(self):
            return self.getToken(SLASHParser.COLON, 0)

        def naf_literals(self):
            return self.getTypedRuleContext(SLASHParser.Naf_literalsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_aggregate_element

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAggregate_element"):
                return visitor.visitAggregate_element(self)
            else:
                return visitor.visitChildren(self)

    def aggregate_element(self):

        localctx = SLASHParser.Aggregate_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_aggregate_element)
        self._la = 0  # Token type
        try:
            self.state = 164
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 24, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 152
                self.terms()
                self.state = 154
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 10:
                    self.state = 153
                    self.match(SLASHParser.COLON)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 156
                self.match(SLASHParser.COLON)
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1114238) != 0:
                    self.state = 157
                    self.naf_literals()

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 160
                self.terms()
                self.state = 161
                self.match(SLASHParser.COLON)
                self.state = 162
                self.naf_literals()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Aggregate_functionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(SLASHParser.COUNT, 0)

        def MAX(self):
            return self.getToken(SLASHParser.MAX, 0)

        def MIN(self):
            return self.getToken(SLASHParser.MIN, 0)

        def SUM(self):
            return self.getToken(SLASHParser.SUM, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_aggregate_function

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAggregate_function"):
                return visitor.visitAggregate_function(self)
            else:
                return visitor.visitChildren(self)

    def aggregate_function(self):

        localctx = SLASHParser.Aggregate_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_aggregate_function)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            _la = self._input.LA(1)
            if not (((_la) & ~0x3F) == 0 and ((1 << _la) & 64424509440) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Naf_literalsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def naf_literal(self):
            return self.getTypedRuleContext(SLASHParser.Naf_literalContext, 0)

        def COMMA(self):
            return self.getToken(SLASHParser.COMMA, 0)

        def naf_literals(self):
            return self.getTypedRuleContext(SLASHParser.Naf_literalsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_naf_literals

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNaf_literals"):
                return visitor.visitNaf_literals(self)
            else:
                return visitor.visitChildren(self)

    def naf_literals(self):

        localctx = SLASHParser.Naf_literalsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_naf_literals)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.naf_literal()
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 8:
                self.state = 169
                self.match(SLASHParser.COMMA)
                self.state = 170
                self.naf_literals()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Naf_literalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classical_literal(self):
            return self.getTypedRuleContext(SLASHParser.Classical_literalContext, 0)

        def NAF(self):
            return self.getToken(SLASHParser.NAF, 0)

        def builtin_atom(self):
            return self.getTypedRuleContext(SLASHParser.Builtin_atomContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_naf_literal

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNaf_literal"):
                return visitor.visitNaf_literal(self)
            else:
                return visitor.visitChildren(self)

    def naf_literal(self):

        localctx = SLASHParser.Naf_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_naf_literal)
        self._la = 0  # Token type
        try:
            self.state = 178
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 27, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 1:
                    self.state = 173
                    self.match(SLASHParser.NAF)

                self.state = 176
                self.classical_literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 177
                self.builtin_atom()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Classical_literalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(SLASHParser.ID, 0)

        def MINUS(self):
            return self.getToken(SLASHParser.MINUS, 0)

        def PAREN_OPEN(self):
            return self.getToken(SLASHParser.PAREN_OPEN, 0)

        def PAREN_CLOSE(self):
            return self.getToken(SLASHParser.PAREN_CLOSE, 0)

        def terms(self):
            return self.getTypedRuleContext(SLASHParser.TermsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_classical_literal

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitClassical_literal"):
                return visitor.visitClassical_literal(self)
            else:
                return visitor.visitChildren(self)

    def classical_literal(self):

        localctx = SLASHParser.Classical_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_classical_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 16:
                self.state = 180
                self.match(SLASHParser.MINUS)

            self.state = 183
            self.match(SLASHParser.ID)
            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 20:
                self.state = 184
                self.match(SLASHParser.PAREN_OPEN)
                self.state = 186
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1114236) != 0:
                    self.state = 185
                    self.terms()

                self.state = 188
                self.match(SLASHParser.PAREN_CLOSE)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Builtin_atomContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SLASHParser.TermContext)
            else:
                return self.getTypedRuleContext(SLASHParser.TermContext, i)

        def relop(self):
            return self.getTypedRuleContext(SLASHParser.RelopContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_builtin_atom

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBuiltin_atom"):
                return visitor.visitBuiltin_atom(self)
            else:
                return visitor.visitChildren(self)

    def builtin_atom(self):

        localctx = SLASHParser.Builtin_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_builtin_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.term()
            self.state = 192
            self.relop()
            self.state = 193
            self.term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelopContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(SLASHParser.EQUAL, 0)

        def UNEQUAL(self):
            return self.getToken(SLASHParser.UNEQUAL, 0)

        def LESS(self):
            return self.getToken(SLASHParser.LESS, 0)

        def GREATER(self):
            return self.getToken(SLASHParser.GREATER, 0)

        def LESS_OR_EQ(self):
            return self.getToken(SLASHParser.LESS_OR_EQ, 0)

        def GREATER_OR_EQ(self):
            return self.getToken(SLASHParser.GREATER_OR_EQ, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_relop

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRelop"):
                return visitor.visitRelop(self)
            else:
                return visitor.visitChildren(self)

    def relop(self):

        localctx = SLASHParser.RelopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_relop)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            _la = self._input.LA(1)
            if not (((_la) & ~0x3F) == 0 and ((1 << _la) & 4227858432) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermsContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(SLASHParser.TermContext, 0)

        def COMMA(self):
            return self.getToken(SLASHParser.COMMA, 0)

        def terms(self):
            return self.getTypedRuleContext(SLASHParser.TermsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_terms

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTerms"):
                return visitor.visitTerms(self)
            else:
                return visitor.visitChildren(self)

    def terms(self):

        localctx = SLASHParser.TermsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_terms)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.term()
            self.state = 200
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 8:
                self.state = 198
                self.match(SLASHParser.COMMA)
                self.state = 199
                self.terms()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(SLASHParser.ID, 0)

        def STRING(self):
            return self.getToken(SLASHParser.STRING, 0)

        def VARIABLE(self):
            return self.getToken(SLASHParser.VARIABLE, 0)

        def ANONYMOUS_VARIABLE(self):
            return self.getToken(SLASHParser.ANONYMOUS_VARIABLE, 0)

        def PAREN_OPEN(self):
            return self.getToken(SLASHParser.PAREN_OPEN, 0)

        def term(self):
            return self.getTypedRuleContext(SLASHParser.TermContext, 0)

        def PAREN_CLOSE(self):
            return self.getToken(SLASHParser.PAREN_CLOSE, 0)

        def func_term(self):
            return self.getTypedRuleContext(SLASHParser.Func_termContext, 0)

        def arith_term(self):
            return self.getTypedRuleContext(SLASHParser.Arith_termContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_term

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTerm"):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)

    def term(self):

        localctx = SLASHParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_term)
        try:
            self.state = 212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 32, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 202
                self.match(SLASHParser.ID)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 203
                self.match(SLASHParser.STRING)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 204
                self.match(SLASHParser.VARIABLE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 205
                self.match(SLASHParser.ANONYMOUS_VARIABLE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 206
                self.match(SLASHParser.PAREN_OPEN)
                self.state = 207
                self.term()
                self.state = 208
                self.match(SLASHParser.PAREN_CLOSE)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 210
                self.func_term()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 211
                self.arith_term()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_termContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(SLASHParser.ID, 0)

        def PAREN_OPEN(self):
            return self.getToken(SLASHParser.PAREN_OPEN, 0)

        def PAREN_CLOSE(self):
            return self.getToken(SLASHParser.PAREN_CLOSE, 0)

        def terms(self):
            return self.getTypedRuleContext(SLASHParser.TermsContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_func_term

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunc_term"):
                return visitor.visitFunc_term(self)
            else:
                return visitor.visitChildren(self)

    def func_term(self):

        localctx = SLASHParser.Func_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_func_term)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(SLASHParser.ID)
            self.state = 215
            self.match(SLASHParser.PAREN_OPEN)
            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 1114236) != 0:
                self.state = 216
                self.terms()

            self.state = 219
            self.match(SLASHParser.PAREN_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arith_termContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arith_sum(self):
            return self.getTypedRuleContext(SLASHParser.Arith_sumContext, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_arith_term

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArith_term"):
                return visitor.visitArith_term(self)
            else:
                return visitor.visitChildren(self)

    def arith_term(self):

        localctx = SLASHParser.Arith_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_arith_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.arith_sum(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arith_sumContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arith_prod(self):
            return self.getTypedRuleContext(SLASHParser.Arith_prodContext, 0)

        def arith_sum(self):
            return self.getTypedRuleContext(SLASHParser.Arith_sumContext, 0)

        def PLUS(self):
            return self.getToken(SLASHParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SLASHParser.MINUS, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_arith_sum

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArith_sum"):
                return visitor.visitArith_sum(self)
            else:
                return visitor.visitChildren(self)

    def arith_sum(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SLASHParser.Arith_sumContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 46
        self.enterRecursionRule(localctx, 46, self.RULE_arith_sum, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.arith_prod(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 234
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 35, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 232
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 34, self._ctx)
                    if la_ == 1:
                        localctx = SLASHParser.Arith_sumContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_arith_sum
                        )
                        self.state = 226
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 2)"
                            )
                        self.state = 227
                        self.match(SLASHParser.PLUS)
                        self.state = 228
                        self.arith_prod(0)
                        pass

                    elif la_ == 2:
                        localctx = SLASHParser.Arith_sumContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_arith_sum
                        )
                        self.state = 229
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 1)"
                            )
                        self.state = 230
                        self.match(SLASHParser.MINUS)
                        self.state = 231
                        self.arith_prod(0)
                        pass

                self.state = 236
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 35, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Arith_prodContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arith_atom(self):
            return self.getTypedRuleContext(SLASHParser.Arith_atomContext, 0)

        def arith_prod(self):
            return self.getTypedRuleContext(SLASHParser.Arith_prodContext, 0)

        def TIMES(self):
            return self.getToken(SLASHParser.TIMES, 0)

        def DIV(self):
            return self.getToken(SLASHParser.DIV, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_arith_prod

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArith_prod"):
                return visitor.visitArith_prod(self)
            else:
                return visitor.visitChildren(self)

    def arith_prod(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SLASHParser.Arith_prodContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 48
        self.enterRecursionRule(localctx, 48, self.RULE_arith_prod, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.arith_atom()
            self._ctx.stop = self._input.LT(-1)
            self.state = 248
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 37, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 246
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 36, self._ctx)
                    if la_ == 1:
                        localctx = SLASHParser.Arith_prodContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_arith_prod
                        )
                        self.state = 240
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 2)"
                            )
                        self.state = 241
                        self.match(SLASHParser.TIMES)
                        self.state = 242
                        self.arith_atom()
                        pass

                    elif la_ == 2:
                        localctx = SLASHParser.Arith_prodContext(
                            self, _parentctx, _parentState
                        )
                        self.pushNewRecursionContext(
                            localctx, _startState, self.RULE_arith_prod
                        )
                        self.state = 243
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException

                            raise FailedPredicateException(
                                self, "self.precpred(self._ctx, 1)"
                            )
                        self.state = 244
                        self.match(SLASHParser.DIV)
                        self.state = 245
                        self.arith_atom()
                        pass

                self.state = 250
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 37, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Arith_atomContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(
            self, parser, parent: ParserRuleContext = None, invokingState: int = -1
        ):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(SLASHParser.NUMBER, 0)

        def VARIABLE(self):
            return self.getToken(SLASHParser.VARIABLE, 0)

        def MINUS(self):
            return self.getToken(SLASHParser.MINUS, 0)

        def arith_atom(self):
            return self.getTypedRuleContext(SLASHParser.Arith_atomContext, 0)

        def PAREN_OPEN(self):
            return self.getToken(SLASHParser.PAREN_OPEN, 0)

        def arith_sum(self):
            return self.getTypedRuleContext(SLASHParser.Arith_sumContext, 0)

        def PAREN_CLOSE(self):
            return self.getToken(SLASHParser.PAREN_CLOSE, 0)

        def getRuleIndex(self):
            return SLASHParser.RULE_arith_atom

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArith_atom"):
                return visitor.visitArith_atom(self)
            else:
                return visitor.visitChildren(self)

    def arith_atom(self):

        localctx = SLASHParser.Arith_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_arith_atom)
        try:
            self.state = 259
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 251
                self.match(SLASHParser.NUMBER)
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 2)
                self.state = 252
                self.match(SLASHParser.VARIABLE)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 3)
                self.state = 253
                self.match(SLASHParser.MINUS)
                self.state = 254
                self.arith_atom()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 4)
                self.state = 255
                self.match(SLASHParser.PAREN_OPEN)
                self.state = 256
                self.arith_sum(0)
                self.state = 257
                self.match(SLASHParser.PAREN_CLOSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[23] = self.arith_sum_sempred
        self._predicates[24] = self.arith_prod_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def arith_sum_sempred(self, localctx: Arith_sumContext, predIndex: int):
        if predIndex == 0:
            return self.precpred(self._ctx, 2)

        if predIndex == 1:
            return self.precpred(self._ctx, 1)

    def arith_prod_sempred(self, localctx: Arith_prodContext, predIndex: int):
        if predIndex == 2:
            return self.precpred(self._ctx, 2)

        if predIndex == 3:
            return self.precpred(self._ctx, 1)
